#вкладка "Потребление товаров"

import streamlit as st  #Streamlit — это фреймворк для языка программирования Python
import pandas as pd
import numpy as np
from scipy.optimize import minimize, LinearConstraint  #функция для нахождения минимума функции

def consumption():  #tabs - это вкладки; number - номер данной вкладки, который передаётся из Main

    st.title("Потребление товаров")

    st.info("Задача представляет собой нахождение оптимального количества товаров каждого вида при заданных ценах на товары и известном доходе потребителя таким образом, чтобы наилучшим образом удовлетворить потребности потребителя")

    #числовое поле ввода для количества видов товаров
    n = st.number_input("Количество видов товаров:",
                            min_value = 1,
                            value = 1,
                            step = 1)

    #создание таблицы для возможности ввода пользователем цен на товары
    price = pd.DataFrame(
    {
        "Вид товара": [i+1 for i in range (n)],
        "price": [0.0 for i in range (n)],
    })
    price = st.data_editor(
        price, #вставка колонок из DataFrame price 
        #конфигурация колонок
        column_config = {  
            "price": st.column_config.NumberColumn(   #колонка таблицы "цена на товар", которую пользователь заполняет значениями
                "Цена на товар",
                min_value = 0,
                step = 0.01,
                format = "%f руб.",
                required = True
            ),
            "Вид товара": st.column_config.NumberColumn(  #колонка таблицы "вид товара", которая нужна для удобства индексации и которую пользователь не может менять
            disabled = True
            )
        },
        hide_index = True
    )
    
    price_mas = price["price"].tolist() #считывание введённых пользователем значений цен в список

    #числовое поле ввода для дохода потребителя
    I = st.number_input("Доход потребителя (в рублях):",
                            min_value = 0.01,
                            value = 0.01,
                            step = 0.01)

    #выбор функции полезности: Кобба-Дугласа или с полным взаимозамещением благ
    options = ["Кобба-Дугласа", "С полным взаимозамещением благ"]
    u = st.radio("Вид функции полезности?", options)
    
    #если пользователь выбирает функцию полезности Кобба-Дугласа 
    if u == "Кобба-Дугласа":
        #числовое поле ввода для ввода первого коэффициента a функции полезности Кобба-Дугласа
        coef_a = st.number_input("Первый коэффициент a:",
                                    min_value = 0.01,
                                    step = 0.01)
        #создание таблицы для возможности ввода пользователем степеней при товарах
        coefs = pd.DataFrame(
            {
                "Вид товара": [i+1 for i in range (n)],
                "coef": [0.01 for i in range (n)],
            }
        )
        coefs = st.data_editor(
            coefs,
            column_config = {
                "coef": st.column_config.NumberColumn(
                    "Степень при товаре",
                    min_value = 0.01,
                    step = 0.01,
                    format = "%f",
                    required = True
                ),
                "Вид товара": st.column_config.NumberColumn(
                    disabled = True
                )
            },
            hide_index = True
        )

        coefs_mas = coefs["coef"].tolist() #считывание введённых пользователем значений коэффициентов в список

        if sum(coefs_mas) != 1:  #проверка, что степени при товарах в сумме дают 1
            st.error(f"Введённые степени при товарах должны в сумме давать 1. Текущая сумма: {sum(coefs_mas)}")
        else:
            #выбор: есть ли заданные наборы товаров, среди которых надо найти оптимальный, или нет
            options = ["Да", "Нет"]
            ok = st.radio("Есть ли заданные наборы товаров, среди которых необходимо найти оптимальный?", options)

            #если пользователь отвечает "Да" на вопрос про заданные наборы товаров
            if ok == "Да":
                #числовое поле ввода для количества рассматриваемых наборов
                m = st.number_input("Количество рассматриваемых наборов:",
                                            min_value = 1,
                                            value = 1,
                                            step = 1)
                #создание таблицы для возможности ввода пользователем количества товаров в заданных наборах
                a = {"Набор": [i+1 for i in range (m)]}   #значения для первого столбца "Набор" 
                b = {"Набор": st.column_config.NumberColumn(  #конфигурация для первого столбца "Набор", которая не позволяет менять значения
                            disabled = True
                        )}
                for i in range(n):  #создание n столбцов "Количество товара 1, 2, 3, ..." и их конфигураций
                    a[f"Количество товара {i+1}"] = [0.0 for j in range (m)]  #значения по умолчанию для столбцов "Количество товара 1, 2, 3, ..."
                    b[f"Количество товара {i+1}"] = st.column_config.NumberColumn(  #конфигурация для столбцов "Количество товара 1, 2, 3, ..."
                            min_value = 0.01,
                            step = 0.01,
                            required = True
                        )
                data_df = pd.DataFrame(a)
                data_df = st.data_editor(data_df, column_config = b, hide_index = True)

                sets = data_df.drop("Набор", axis = 1).to_numpy().tolist() #сбор введённых пользователем значений для наборов в матрицу, где i - номер набора, j - количество товара j-го вида

                #дальнейший код нужен для расчёта значения функции полезности и стоимости каждого из введённых наборов
                f = [] #элементы одномерного массива f будут представлять собой подсчёт значения функции полезности для каждого из введённых наборов
                for i in range(m):
                    f.append(1)
                    for j in range(n):
                        f[i] *= sets[i][j]**coefs_mas[j]  
                    f[i] *= coef_a
                cost = []  #элементы одномерного массива cost будут представлять собой подсчёт значения стоимости каждого из введённых наборов
                for i in range(m):
                    cost.append(0)
                    for j in range(n):
                        cost[i] += sets[i][j]*price_mas[j]

                #дальнейший код нужен для выявления набора с наибольшей полезностью и подходящим под бюджет среди введённых наборов 
                sets_with_correct_cost = []  #массив с подходящими по стоимости наборами (те, которые не превышают доход)
                f_sets_with_correct_cost = []  #массив со значением функции полезности для соответствующих подходящих по стоимости наборов 
                for i in range(m):  #заполнение двух массивов, созданных выше
                    if cost[i] <= I:
                        sets_with_correct_cost.append(i)
                        f_sets_with_correct_cost.append(f[i])
                max_correct_f = max(f_sets_with_correct_cost)  #максимальное значение функции полезности из подходящих наборов
                good_sets_n = []  #массив для номеров подходящих по стоимости и с максимальной полезностью наборов
                good_cost = []   #массив для стоимостей подходящих по стоимости и с максимальной полезностью наборов
                for i in sets_with_correct_cost: #заполнение двух массивов, созданных выше
                    if f[i] == max_correct_f:
                        good_sets_n.append(i)
                        good_cost.append(cost[i])

                #вывод результатов
                st.write(f"Максимальная полезность: {round(max_correct_f, 3)}")
                st.write(f"Наборы с максимальной полезностью:")
                for i in range(len(good_sets_n)):
                    st.write(f"Набор {good_sets_n[i]+1}, стоимость которого {round(good_cost[i], 3)} руб.")

            #если пользователь отвечает "нет" на вопрос про заданные наборы товаров
            else:
                def f(x):  #необходимо "собрать" функцию, которую будем минимизировать (максимизировать u = минимизировать -u), аргументом которой будут только неизвестные количества товаров, то есть массив x
                    pr = -coef_a
                    for i in range (n):
                        pr *= x[i]**coefs_mas[i]
                    return pr
                #далее код для создания линейных ограничений в виде объекта LinearConstraint
                #0 <= p1x1 + p2x2 + ... <= I
                #0 <= x1 <= np.inf
                #0 <= x2 <= np.inf
                #...
                A = [] #матрица A представляет собой "центральную" матрицу для создания ограничений в виде объекта LinearConstraint
                A.append(price_mas) #в первой строчке матрицы A будут цены на товары
                for i in range(n):
                    A.append([])
                    for j in range(n):
                        if i == j:
                            A[i+1].append(1) #ниже первой строчки, где цены на товары (поэтому i+1). будут стоять единицы в соответствующем столбце каждой строки (при i = j)
                        else:
                            A[i+1].append(0)
                B = [0] #матрица B представляет собой "левую" матрицу для создания ограничений в виде объекта LinearConstraint 
                C = [I]  #матрица C представляет собой "правую" матрицу для создания ограничений в виде объекта LinearConstraint
                for i in range (n):
                    B.append(0)
                    C.append(np.inf)
                linear_constraint = LinearConstraint(A, B, C)
                x_start = np.array([0 for i in range(n)]) #x_start представляет собой начальное предположение точки минимума
                result = minimize(f, x_start, method = 'trust-constr', constraints = linear_constraint)
                good_set = result.x.tolist() #запись значений вектора x = (x_1, x_2, ..., x_n), так как в result не только значения x находятся, а много всего 
                max_f = f(good_set) #нахождение значения функции полезности для этого набора
                #нахождение стоимости этого набора
                good_cost = 0
                for i in range (n):
                    good_cost += good_set[i]*price_mas[i]
                st.write(f"Максимальная полезность: {round(-max_f, 3)}")
                #преобразование значений количества товаров в полученном наборе до трёх знаков после запятой каждого элемента
                s = ''
                for i in good_set:
                    s += f"{round(i,3)}, "
                st.write(f"Набор с максимальной полезностью: ({s[:-2]})") #срез до предпоследнего элемента для избавления от запятой и пробела после последнего элемента
                st.write(f"Стоимость этого набора: {round(good_cost,2)} руб.")

    else:  #если пользователь выбирает функцию полезности с полным взаимозамещением благ
        #создание таблицы для возможности ввода пользователем коэффициентов при товарах
        coefs = pd.DataFrame(
            {
                "Вид товара": [i+1 for i in range (n)],
                "coef": [0.01 for i in range (n)],
            }
        )
        coefs = st.data_editor(
            coefs,
            column_config = {
                "coef": st.column_config.NumberColumn(
                    "Коэффициент при товаре",
                    min_value = 0.01,
                    step = 0.01,
                    format = "%f",
                    required = True
                ),
                "Вид товара": st.column_config.NumberColumn(
                    disabled = True
                )
            },
            hide_index = True
        )

        coefs_mas = coefs["coef"].tolist() #считывание введённых пользователем значений коэффициентов в список

        #выбор: есть ли заданные наборы товаров, среди которых надо найти оптимальный, или нет
        options = ["Да", "Нет"]
        ok = st.radio("Есть ли заданные наборы товаров, среди которых необходимо найти оптимальный?", options)

        #если пользователь отвечает "Да" на вопрос про заданные наборы товаров
        if ok == "Да":
            #числовое поле ввода для количества рассматриваемых наборов
            m = st.number_input("Количество рассматриваемых наборов:",
                                        min_value = 1,
                                        value = 1,
                                        step = 1)
            #создание таблицы для возможности ввода пользователем количества товаров в заданных наборах
            a = {"Набор": [i+1 for i in range (m)]}   #значения для первого столбца "Набор" 
            b = {"Набор": st.column_config.NumberColumn(  #конфигурация для первого столбца "Набор", которая не позволяет менять значения
                        disabled = True
                    )}
            for i in range(n):  #создание n столбцов "Количество товара 1, 2, 3, ..." и их конфигураций
                a[f"Количество товара {i+1}"] = [0.0 for j in range (m)]  #значения по умолчанию для столбцов "Количество товара 1, 2, 3, ..."
                b[f"Количество товара {i+1}"] = st.column_config.NumberColumn(  #конфигурация для столбцов "Количество товара 1, 2, 3, ..."
                        min_value = 0.01,
                        step = 0.01,
                        required = True
                    )
            data_df = pd.DataFrame(a)
            data_df = st.data_editor(data_df, column_config = b, hide_index = True)

            sets = data_df.drop("Набор", axis = 1).to_numpy().tolist() #сбор введённых пользователем значений для наборов в матрицу, где i - номер набора, j - количество товара j-го вида

            #дальнейший код нужен для расчёта значения функции полезности и стоимости каждого из введённых наборов
            f = [] #элементы одномерного массива f будут представлять собой подсчёт значения функции полезности для каждого из введённых наборов
            for i in range(m):
                f.append(0)
                for j in range(n):
                    f[i] += sets[i][j]*coefs_mas[j]  
            cost = []  #элементы одномерного массива cost будут представлять собой подсчёт значения стоимости каждого из введённых наборов
            for i in range(m):
                cost.append(0)
                for j in range(n):
                    cost[i] += sets[i][j]*price_mas[j]

            #дальнейший код нужен для выявления набора с наибольшей полезностью и подходящим под бюджет среди введённых наборов 
            sets_with_correct_cost = []  #массив с подходящими по стоимости наборами (те, которые не превышают доход)
            f_sets_with_correct_cost = []  #массив со значением функции полезности для соответствующих подходящих по стоимости наборов 
            for i in range(m):  #заполнение двух массивов, созданных выше
                if cost[i] <= I:
                    sets_with_correct_cost.append(i)
                    f_sets_with_correct_cost.append(f[i])
            max_correct_f = max(f_sets_with_correct_cost)  #максимальное значение функции полезности из подходящих наборов
            good_sets_n = []  #массив для номеров подходящих по стоимости и с максимальной полезностью наборов
            good_cost = []   #массив для стоимостей подходящих по стоимости и с максимальной полезностью наборов
            for i in sets_with_correct_cost: #заполнение двух массивов, созданных выше
                if f[i] == max_correct_f:
                    good_sets_n.append(i)
                    good_cost.append(cost[i])

            #вывод результатов
            st.write(f"Максимальная полезность: {round(max_correct_f, 3)}")
            st.write(f"Наборы с максимальной полезностью:")
            for i in range(len(good_sets_n)):
                st.write(f"Набор {good_sets_n[i]+1}, стоимость которого {round(good_cost[i], 3)} руб.")

        #если пользователь отвечает "нет" на вопрос про заданные наборы товаров
        else:
            def f(x):  #необходимо "собрать" функцию, которую будем минимизировать (максимизировать u = минимизировать -u), аргументом которой будут только неизвестные количества товаров, то есть массив x
                for i in range (n):
                    summa -= x[i]*coefs_mas[i]
                return summa
            #далее код для создания линейных ограничений в виде объекта LinearConstraint
            #0 <= p1x1 + p2x2 + ... <= I
            #0 <= x1 <= np.inf
            #0 <= x2 <= np.inf
            #...
            A = [] #матрица A представляет собой "центральную" матрицу для создания ограничений в виде объекта LinearConstraint
            A.append(price_mas) #в первой строчке матрицы A будут цены на товары
            for i in range(n):
                A.append([])
                for j in range(n):
                    if i == j:
                        A[i+1].append(1) #ниже первой строчки, где цены на товары (поэтому i+1). будут стоять единицы в соответствующем столбце каждой строки (при i = j)
                    else:
                        A[i+1].append(0)
            B = [-np.inf] #матрица B представляет собой "левую" матрицу для создания оганичений в виде объекта LinearConstraint Почему не 0, а np.inf?
            C = [I]  #матрица C представляет собой "правую" матрицу для создания оганичений в виде объекта LinearConstraint
            for i in range (n):
                B.append(0)
                C.append(np.inf)
            linear_constraint = LinearConstraint(A, B, C)
            x_start = np.array([0 for i in range(n)]) #x_start представляет собой начальное предположение точки минимума
            result = minimize(f, x_start, method = 'trust-constr', constraints = linear_constraint)
            good_set = result.x.tolist() #запись значений вектора x = (x1,x2, ...)
            max_f = f(good_set) #нахождение значения функции полезности для этого набора
            #нахождение стоимости этого набора
            good_cost = 0
            for i in range (n):
                good_cost += good_set[i]*price_mas[i]
            st.write(f"Максимальная полезность: {round(-max_f, 3)}")
            #преобразование значений количества товаров в полученном наборе до трёх знаков после запятой каждого элемента
            s = ''
            for i in good_set:
                s += f"{round(i,3)}, "
            st.write(f"Набор с максимальной полезностью: ({s[:-2]})") #срез до предпоследнего элемента для избавления от пробела осле последнего элемента
            st.write(f"Стоимость этого набора: {round(good_cost,2)} руб.")
        






